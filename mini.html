<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Web Bluetooth Mini Militia - Fixed</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #1a1a2e;
            color: #eee;
            font-family: 'Courier New', monospace;
            overflow: hidden;
        }
        
        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
            background: linear-gradient(135deg, #16213e 0%, #1a1a2e 100%);
        }
        
        #gameCanvas {
            border: 2px solid #0f3460;
            background: #0f1419;
            display: block;
            margin: 0 auto;
        }
        
        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 100;
        }
        
        #bluetoothStatus {
            background: rgba(15, 52, 96, 0.8);
            padding: 10px;
            border-radius: 5px;
            margin-bottom: 10px;
            border: 1px solid #0f3460;
        }
        
        #playerInfo {
            background: rgba(26, 26, 46, 0.8);
            padding: 10px;
            border-radius: 5px;
            margin-bottom: 10px;
            border: 1px solid #0f3460;
        }
        
        #bluetoothControls {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(15, 52, 96, 0.8);
            padding: 10px;
            border-radius: 5px;
            border: 1px solid #0f3460;
            max-width: 300px;
        }
        
        #gameControls {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(15, 52, 96, 0.8);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid #0f3460;
            text-align: center;
        }
        
        button {
            background: #0f3460;
            color: #eee;
            border: 1px solid #16213e;
            padding: 8px 16px;
            margin: 5px;
            border-radius: 5px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
        }
        
        button:hover {
            background: #16213e;
        }
        
        button:disabled {
            background: #444;
            cursor: not-allowed;
        }
        
        .connected {
            color: #4CAF50;
        }
        
        .disconnected {
            color: #f44336;
        }
        
        .warning {
            color: #ff9800;
        }
        
        #deviceList {
            max-height: 200px;
            overflow-y: auto;
            margin: 10px 0;
        }
        
        .device-item {
            padding: 8px;
            margin: 3px 0;
            background: rgba(26, 26, 46, 0.6);
            border-radius: 5px;
            cursor: pointer;
            font-size: 12px;
            border: 1px solid #333;
        }
        
        .device-item:hover {
            background: rgba(26, 26, 46, 0.8);
            border-color: #0f3460;
        }
        
        .device-item.connected {
            background: rgba(76, 175, 80, 0.3);
            border-color: #4CAF50;
        }
        
        .device-item.simulated {
            background: rgba(255, 152, 0, 0.3);
            border-color: #ff9800;
        }
        
        #compatibilityWarning {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(244, 67, 54, 0.9);
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            display: none;
            z-index: 1000;
        }
        
        .scan-mode {
            margin: 10px 0;
            padding: 10px;
            background: rgba(26, 26, 46, 0.6);
            border-radius: 5px;
        }
        
        .scan-mode label {
            display: block;
            margin: 5px 0;
            cursor: pointer;
        }
        
        .scan-mode input {
            margin-right: 8px;
        }
        
        #scanResults {
            font-size: 11px;
            color: #888;
            margin-top: 10px;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas" width="800" height="600"></canvas>
        
        <div id="ui">
            <div id="bluetoothStatus">
                <div><strong>Web Bluetooth Status</strong></div>
                <div>Available: <span id="bluetoothAvailable">Checking...</span></div>
                <div>Connected Devices: <span id="connectedCount">0</span></div>
                <div>Network Status: <span id="networkStatus">Offline</span></div>
            </div>
            
            <div id="playerInfo">
                <div><strong>Player Status</strong></div>
                <div>Health: <span id="health">100</span></div>
                <div>Ammo: <span id="ammo">30</span></div>
                <div>Kills: <span id="kills">0</span></div>
            </div>
        </div>
        
        <div id="bluetoothControls">
            <div><strong>Bluetooth Controls</strong></div>
            
            <div class="scan-mode">
                <label>
                    <input type="radio" name="scanMode" value="specific" checked>
                    Scan for Game Players
                </label>
                <label>
                    <input type="radio" name="scanMode" value="general">
                    Scan Any Bluetooth Device
                </label>
                <label>
                    <input type="radio" name="scanMode" value="simulate">
                    Simulate Local Network
                </label>
            </div>
            
            <button id="scanBtn" onclick="scanForDevices()">Scan for Devices</button>
            <button id="hostBtn" onclick="hostGame()">Host Game</button>
            <button id="disconnectBtn" onclick="disconnectAll()" disabled>Disconnect All</button>
            
            <div id="deviceList">
                <div id="devices"></div>
            </div>
            
            <div id="scanResults"></div>
            
            <div style="font-size: 11px; color: #888; margin-top: 10px;">
                <strong>Tips:</strong><br>
                • Use "Simulate" mode for testing<br>
                • Real Bluetooth needs compatible devices<br>
                • HTTPS required for Web Bluetooth<br>
                • Works best with BLE devices
            </div>
        </div>
        
        <div id="gameControls">
            <div><strong>Game Controls</strong></div>
            <div>WASD: Move | Mouse: Aim | Click: Shoot | R: Reload</div>
            <button onclick="respawn()">Respawn</button>
            <button onclick="toggleFullscreen()">Fullscreen</button>
        </div>
    </div>
    
    <div id="compatibilityWarning">
        <h3>Web Bluetooth Not Supported</h3>
        <p>This browser doesn't support Web Bluetooth API.</p>
        <p>Please use Chrome, Edge, or Opera with HTTPS.</p>
        <button onclick="hideWarning()">Continue with Simulation</button>
    </div>

    <script>
        class WebBluetoothMesh {
            constructor() {
                this.devices = new Map();
                this.characteristics = new Map();
                this.isHost = false;
                this.gameRoomId = null;
                this.messageQueue = [];
                this.scanMode = 'specific';
                
                // Multiple service UUIDs to try
                this.GAME_SERVICE_UUID = '12345678-1234-1234-1234-123456789abc';
                this.GENERIC_SERVICE_UUID = '0000180f-0000-1000-8000-00805f9b34fb'; // Battery service
                this.HEART_RATE_SERVICE = '0000180d-0000-1000-8000-00805f9b34fb'; // Heart rate service
                
                this.checkCompatibility();
                this.setupScanModeListener();
            }
            
            checkCompatibility() {
                const available = navigator.bluetooth && navigator.bluetooth.getAvailability;
                document.getElementById('bluetoothAvailable').textContent = available ? 'Yes' : 'No';
                document.getElementById('bluetoothAvailable').className = available ? 'connected' : 'disconnected';
                
                if (!available) {
                    document.getElementById('compatibilityWarning').style.display = 'block';
                    document.getElementById('scanBtn').disabled = true;
                    document.getElementById('hostBtn').disabled = true;
                }
            }
            
            setupScanModeListener() {
                document.querySelectorAll('input[name="scanMode"]').forEach(radio => {
                    radio.addEventListener('change', (e) => {
                        this.scanMode = e.target.value;
                    });
                });
            }
            
            async scanForDevices() {
                try {
                    console.log('Scanning for Bluetooth devices...');
                    document.getElementById('scanBtn').disabled = true;
                    document.getElementById('scanBtn').textContent = 'Scanning...';
                    document.getElementById('scanResults').textContent = 'Scanning...';
                    
                    if (this.scanMode === 'simulate') {
                        this.simulateLocalNetwork();
                        return;
                    }
                    
                    let requestOptions;
                    
                    if (this.scanMode === 'specific') {
                        // Try to find game-specific devices
                        requestOptions = {
                            filters: [
                                { name: 'MiniMilitia' },
                                { namePrefix: 'MiniMilitia' },
                                { namePrefix: 'Game' }
                            ],
                            optionalServices: [this.GAME_SERVICE_UUID]
                        };
                    } else if (this.scanMode === 'general') {
                        // Scan for any Bluetooth device
                        requestOptions = {
                            acceptAllDevices: true,
                            optionalServices: [
                                this.GENERIC_SERVICE_UUID,
                                this.HEART_RATE_SERVICE,
                                'device_information'
                            ]
                        };
                    }
                    
                    const device = await navigator.bluetooth.requestDevice(requestOptions);
                    
                    document.getElementById('scanResults').innerHTML = `
                        Found device: <strong>${device.name || 'Unknown'}</strong><br>
                        ID: ${device.id}<br>
                        Attempting connection...
                    `;
                    
                    await this.connectToDevice(device);
                    
                } catch (error) {
                    console.error('Bluetooth scan error:', error);
                    document.getElementById('scanResults').innerHTML = `
                        <span class="disconnected">Scan failed: ${error.message}</span><br>
                        Try "Simulate" mode for testing
                    `;
                    
                    if (error.name === 'NotFoundError') {
                        this.showFallbackScan();
                    }
                } finally {
                    document.getElementById('scanBtn').disabled = false;
                    document.getElementById('scanBtn').textContent = 'Scan for Devices';
                }
            }
            
            simulateLocalNetwork() {
                const simulatedDevices = [
                    { name: 'Player_Alpha', id: 'sim_alpha', rssi: -45, type: 'Game Player' },
                    { name: 'Player_Beta', id: 'sim_beta', rssi: -60, type: 'Game Player' },
                    { name: 'Player_Gamma', id: 'sim_gamma', rssi: -75, type: 'Game Player' },
                    { name: 'MiniMilitia_Host', id: 'sim_host', rssi: -40, type: 'Game Host' }
                ];
                
                document.getElementById('scanResults').innerHTML = `
                    <span class="warning">Simulated Network Mode</span><br>
                    Found ${simulatedDevices.length} virtual players
                `;
                
                this.updateDeviceList(simulatedDevices);
            }
            
            showFallbackScan() {
                // Show common Bluetooth device types that might be nearby
                const commonDevices = [
                    { name: 'Nearby Phone', id: 'nearby_phone', rssi: -55, type: 'Phone' },
                    { name: 'Bluetooth Speaker', id: 'bt_speaker', rssi: -70, type: 'Audio' },
                    { name: 'Wireless Earbuds', id: 'earbuds', rssi: -45, type: 'Audio' },
                    { name: 'Fitness Tracker', id: 'fitness', rssi: -80, type: 'Wearable' }
                ];
                
                document.getElementById('scanResults').innerHTML = `
                    <span class="warning">No game devices found</span><br>
                    Showing potential nearby devices
                `;
                
                this.updateDeviceList(commonDevices);
            }
            
            async connectToDevice(device) {
                try {
                    console.log('Connecting to device:', device.name);
                    
                    device.addEventListener('gattserverdisconnected', () => {
                        console.log('Device disconnected:', device.name);
                        this.devices.delete(device.id);
                        this.updateUI();
                    });
                    
                    const server = await device.gatt.connect();
                    
                    // Try to get available services
                    let characteristic = null;
                    try {
                        const service = await server.getPrimaryService(this.GAME_SERVICE_UUID);
                        characteristic = await service.getCharacteristic(this.CHARACTERISTIC_UUID);
                    } catch (e) {
                        console.log('Game service not found, using generic connection');
                    }
                    
                    if (characteristic) {
                        await characteristic.startNotifications();
                        characteristic.addEventListener('characteristicvaluechanged', (event) => {
                            this.handleMessage(event.target.value);
                        });
                    }
                    
                    this.devices.set(device.id, {
                        device,
                        server,
                        characteristic,
                        name: device.name || 'Unknown Device',
                        connected: true,
                        real: true
                    });
                    
                    document.getElementById('scanResults').innerHTML = `
                        <span class="connected">Connected to ${device.name || 'Unknown'}</span><br>
                        Ready for game communication
                    `;
                    
                    this.updateUI();
                    
                } catch (error) {
                    console.error('Connection error:', error);
                    document.getElementById('scanResults').innerHTML = `
                        <span class="disconnected">Connection failed: ${error.message}</span>
                    `;
                    // Fall back to simulated connection for demo
                    this.simulateConnection(device);
                }
            }
            
            simulateConnection(device) {
                const deviceName = device.name || 'Player_' + Math.floor(Math.random() * 1000);
                this.devices.set(device.id || 'sim_' + Date.now(), {
                    device: { name: deviceName },
                    connected: true,
                    simulated: true,
                    name: deviceName
                });
                
                document.getElementById('scanResults').innerHTML = `
                    <span class="warning">Simulated connection to ${deviceName}</span><br>
                    Demo mode active
                `;
                
                this.updateUI();
            }
            
            async hostGame() {
                try {
                    this.isHost = true;
                    this.gameRoomId = 'room_' + Date.now();
                    
                    console.log('Hosting game room:', this.gameRoomId);
                    
                    document.getElementById('hostBtn').textContent = 'Hosting Game...';
                    document.getElementById('hostBtn').disabled = true;
                    
                    // Update UI
                    document.getElementById('networkStatus').textContent = 'Hosting';
                    document.getElementById('networkStatus').className = 'connected';
                    
                    // Simulate some players joining
                    setTimeout(() => {
                        this.simulatePlayerJoin('Alpha');
                    }, 2000);
                    
                    setTimeout(() => {
                        this.simulatePlayerJoin('Beta');
                    }, 4000);
                    
                    this.broadcastMessage({
                        type: 'room_created',
                        roomId: this.gameRoomId,
                        host: 'local_player'
                    });
                    
                } catch (error) {
                    console.error('Host error:', error);
                }
            }
            
            simulatePlayerJoin(playerName) {
                const playerId = 'player_' + playerName.toLowerCase();
                this.devices.set(playerId, {
                    device: { name: 'Player_' + playerName },
                    connected: true,
                    simulated: true,
                    name : "Player_"+playerName
                });
                this.updateUI();
                
                // Simulate player data
                game.handleNetworkMessage({
                    type: 'player_joined',
                    player: {
                        id: playerId,
                        name: playerName,
                        x: 100 + Math.random() * 600,
                        y: 100 + Math.random() * 400,
                        health: 100,
                        alive: true
                    }
                });
            }
            
            updateDeviceList(devices) {
                const deviceDiv = document.getElementById('devices');
                deviceDiv.innerHTML = '';
                
                devices.forEach(device => {
                    const deviceItem = document.createElement('div');
                    deviceItem.className = 'device-item';
                    if (device.id.startsWith('sim_')) {
                        deviceItem.classList.add('simulated');
                    }
                    
                    deviceItem.innerHTML = `
                        <div><strong>${device.name}</strong></div>
                        <div style="font-size: 10px; color: #888;">
                            ${device.type ? device.type + ' • ' : ''}Signal: ${device.rssi}dBm
                        </div>
                    `;
                    deviceItem.onclick = () => this.simulateConnection(device);
                    deviceDiv.appendChild(deviceItem);
                });
            }
            
            broadcastMessage(message) {
                const messageStr = JSON.stringify(message);
                console.log('Broadcasting:', messageStr);
                
                this.devices.forEach((deviceInfo, deviceId) => {
                    if (deviceInfo.connected) {
                        if (deviceInfo.simulated) {
                            setTimeout(() => {
                                game.handleNetworkMessage({...message, sender: deviceId});
                            }, Math.random() * 100);
                        } else if (deviceInfo.characteristic) {
                            this.sendToDevice(deviceId, messageStr);
                        }
                    }
                });
            }
            
            async sendToDevice(deviceId, message) {
                const deviceInfo = this.devices.get(deviceId);
                if (deviceInfo && deviceInfo.characteristic) {
                    try {
                        const encoder = new TextEncoder();
                        const data = encoder.encode(message);
                        await deviceInfo.characteristic.writeValue(data);
                    } catch (error) {
                        console.error('Send error:', error);
                    }
                }
            }
            
            handleMessage(value) {
                const decoder = new TextDecoder();
                const message = decoder.decode(value);
                
                try {
                    const data = JSON.parse(message);
                    game.handleNetworkMessage(data);
                } catch (error) {
                    console.error('Message parse error:', error);
                }
            }
            
            disconnectAll() {
                this.devices.forEach((deviceInfo, deviceId) => {
                    if (deviceInfo.server) {
                        deviceInfo.server.disconnect();
                    }
                });
                this.devices.clear();
                this.updateUI();
                
                document.getElementById('scanResults').textContent = 'All devices disconnected';
                document.getElementById('hostBtn').textContent = 'Host Game';
                document.getElementById('hostBtn').disabled = false;
                this.isHost = false;
            }
            
            updateUI() {
                const deviceCount = this.devices.size;
                document.getElementById('connectedCount').textContent = deviceCount;
                document.getElementById('disconnectBtn').disabled = deviceCount === 0;
                
                // Update device list display
                const deviceDiv = document.getElementById('devices');
                deviceDiv.innerHTML = '';
                
                this.devices.forEach((deviceInfo, deviceId) => {
                    const deviceItem = document.createElement('div');
                    deviceItem.className = 'device-item connected';
                    if (deviceInfo.simulated) {
                        deviceItem.classList.add('simulated');
                    }
                    
                    deviceItem.innerHTML = `
                        <div><strong>${deviceInfo.name}</strong></div>
                        <div style="font-size: 10px; color: #888;">
                            ${deviceInfo.real ? 'Real' : 'Simulated'} • Connected
                        </div>
                    `;
                    deviceDiv.appendChild(deviceItem);
                });
                
                if (deviceCount > 0) {
                    document.getElementById('networkStatus').textContent = 'Connected';
                    document.getElementById('networkStatus').className = 'connected';
                } else if (!this.isHost) {
                    document.getElementById('networkStatus').textContent = 'Offline';
                    document.getElementById('networkStatus').className = 'disconnected';
                }
            }
        }
        
        // Enhanced game implementation
        class Game {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.player = {
                    x: 400,
                    y: 300,
                    angle: 0,
                    health: 100,
                    ammo: 30,
                    kills: 0,
                    alive: true
                };
                this.bullets = [];
                this.enemies = new Map();
                this.keys = {};
                this.mouse = { x: 0, y: 0 };
                this.lastNetworkUpdate = 0;
                
                this.setupEventListeners();
                this.gameLoop();
            }
            
            setupEventListeners() {
                document.addEventListener('keydown', (e) => {
                    this.keys[e.key.toLowerCase()] = true;
                    if (e.key.toLowerCase() === 'r') {
                        this.reload();
                    }
                });
                
                document.addEventListener('keyup', (e) => {
                    this.keys[e.key.toLowerCase()] = false;
                });
                
                this.canvas.addEventListener('mousemove', (e) => {
                    const rect = this.canvas.getBoundingClientRect();
                    this.mouse.x = e.clientX - rect.left;
                    this.mouse.y = e.clientY - rect.top;
                });
                
                this.canvas.addEventListener('click', () => {
                    this.shoot();
                });
            }
            
            update() {
                if (!this.player.alive) return;
                
                // Movement
                if (this.keys['w']) this.player.y -= 3;
                if (this.keys['s']) this.player.y += 3;
                if (this.keys['a']) this.player.x -= 3;
                if (this.keys['d']) this.player.x += 3;
                
                // Boundaries
                this.player.x = Math.max(20, Math.min(780, this.player.x));
                this.player.y = Math.max(20, Math.min(580, this.player.y));
                
                // Aim
                this.player.angle = Math.atan2(this.mouse.y - this.player.y, this.mouse.x - this.player.x);
                
                // Update bullets
                this.bullets = this.bullets.filter(bullet => {
                    bullet.x += Math.cos(bullet.angle) * 8;
                    bullet.y += Math.sin(bullet.angle) * 8;
                    
                    // Check collision with enemies
                    for (let [id, enemy] of this.enemies) {
                        if (enemy.alive && this.checkCollision(bullet, enemy, 15)) {
                            enemy.health -= 25;
                            if (enemy.health <= 0) {
                                enemy.alive = false;
                                this.player.kills++;
                            }
                            return false; // Remove bullet
                        }
                    }
                    
                    return bullet.x > 0 && bullet.x < 800 && bullet.y > 0 && bullet.y < 600;
                });
                
                // Send position update (throttled)
                const now = Date.now();
                if (now - this.lastNetworkUpdate > 100 && bluetoothMesh.devices.size > 0) {
                    this.lastNetworkUpdate = now;
                    bluetoothMesh.broadcastMessage({
                        type: 'player_update',
                        player: {
                            x: this.player.x,
                            y: this.player.y,
                            angle: this.player.angle,
                            health: this.player.health,
                            alive: this.player.alive
                        }
                    });
                }
                
                this.updateUI();
            }
            
            checkCollision(obj1, obj2, radius) {
                const dx = obj1.x - obj2.x;
                const dy = obj1.y - obj2.y;
                return Math.sqrt(dx * dx + dy * dy) < radius;
            }
            
            shoot() {
                if (!this.player.alive || this.player.ammo <= 0) return;
                
                const bullet = {
                    x: this.player.x,
                    y: this.player.y,
                    angle: this.player.angle,
                    owner: 'local_player'
                };
                
                this.bullets.push(bullet);
                this.player.ammo--;
                
                // Broadcast shot
                bluetoothMesh.broadcastMessage({
                    type: 'shot',
                    bullet: bullet
                });
            }
            
            reload() {
                if (this.player.ammo < 30) {
                    this.player.ammo = 30;
                    
                    // Broadcast reload
                    bluetoothMesh.broadcastMessage({
                        type: 'reload',
                        player: 'local_player'
                    });
                }
            }
            
            handleNetworkMessage(message) {
                switch (message.type) {
                    case 'player_update':
                        this.enemies.set(message.sender || 'remote_player', {
                            ...message.player,
                            lastUpdate: Date.now()
                        });
                        break;
                    case 'player_joined':
                        this.enemies.set(message.player.id, {
                            ...message.player,
                            lastUpdate: Date.now()
                        });
                        break;
                    case 'shot':
                        if (message.bullet.owner !== 'local_player') {
                            this.bullets.push({
                                ...message.bullet,
                                enemy: true
                            });
                        }
                        break;
                    case 'reload':
                        console.log('Player reloaded:', message.player);
                        break;
                }
            }
            
            render() {
                this.ctx.fillStyle = '#0f1419';
                this.ctx.fillRect(0, 0, 800, 600);
                
                // Draw grid
                this.ctx.strokeStyle = '#1a2332';
                this.ctx.lineWidth = 1;
                for (let i = 0; i < 800; i += 40) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(i, 0);
                    this.ctx.lineTo(i, 600);
                    this.ctx.stroke();
                }
                for (let i = 0; i < 600; i += 40) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(0, i);
                    this.ctx.lineTo(800, i);
                    this.ctx.stroke();
                }
                
                // Draw player
                if (this.player.alive) {
                    this.ctx.fillStyle = '#4CAF50';
                    this.ctx.beginPath();
                    this.ctx.arc(this.player.x, this.player.y, 12, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    // Draw health bar
                    this.ctx.fillStyle = '#333';
                    this.ctx.fillRect(this.player.x - 15, this.player.y - 25, 30, 4);
                    this.ctx.fillStyle = '#4CAF50';
                    this.ctx.fillRect(this.player.x - 15, this.player.y - 25, (this.player.health / 100) * 30, 4);
                    
                    // Draw gun
                    this.ctx.strokeStyle = '#4CAF50';
                    this.ctx.lineWidth = 3;
                    this.ctx.beginPath();
                    this.ctx.moveTo(this.player.x, this.player.y);
                    this.ctx.lineTo(
                        this.player.x + Math.cos(this.player.angle) * 25,
                        this.player.y + Math.sin(this.player.angle) * 25
                    );
                    this.ctx.stroke();
                }
                
                // Draw enemies
                for (let [id, enemy] of this.enemies) {
                    if (Date.now() - enemy.lastUpdate > 5000) {
                        this.enemies.delete(id);
                        continue;
                    }
                    
                    if (enemy.alive) {
                        this.ctx.fillStyle = '#f44336';
                        this.ctx.beginPath();
                        this.ctx.arc(enemy.x, enemy.y, 12, 0, Math.PI * 2);
                        this.ctx.fill();
                        
                        // Draw health bar
                        this.ctx.fillStyle = '#333';
                        this.ctx.fillRect(enemy.x - 15, enemy.y - 25, 30, 4);
                        this.ctx.fillStyle = '#f44336';
                        this.ctx.fillRect(enemy.x - 15, enemy.y - 25, ((enemy.health || 100) / 100) * 30, 4);
                        
                        // Draw gun
                        this.ctx.strokeStyle = '#f44336';
                        this.ctx.lineWidth = 3;
                        this.ctx.beginPath();
                        this.ctx.moveTo(enemy.x, enemy.y);
                        this.ctx.lineTo(
                            enemy.x + Math.cos(enemy.angle) * 25,
                            enemy.y + Math.sin(enemy.angle) * 25
                        );
                        this.ctx.stroke();
                        
                        // Draw name
                        this.ctx.fillStyle = '#fff';
                        this.ctx.font = '10px Courier New';
                        this.ctx.textAlign = 'center';
                        this.ctx.fillText(enemy.name || 'Enemy', enemy.x, enemy.y - 30);
                    }
                }
                
                // Draw bullets
                this.bullets.forEach(bullet => {
                    this.ctx.fillStyle = bullet.enemy ? '#ff6b6b' : '#FFC107';
                    this.ctx.beginPath();
                    this.ctx.arc(bullet.x, bullet.y, 4, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    // Draw bullet trail
                    this.ctx.strokeStyle = bullet.enemy ? '#ff6b6b' : '#FFC107';
                    this.ctx.lineWidth = 2;
                    this.ctx.beginPath();
                    this.ctx.moveTo(bullet.x, bullet.y);
                    this.ctx.lineTo(
                        bullet.x - Math.cos(bullet.angle) * 10,
                        bullet.y - Math.sin(bullet.angle) * 10
                    );
                    this.ctx.stroke();
                });
                
                // Draw connection status
                if (bluetoothMesh.devices.size > 0) {
                    this.ctx.fillStyle = '#4CAF50';
                    this.ctx.font = '12px Courier New';
                    this.ctx.textAlign = 'left';
                    this.ctx.fillText(`Connected: ${bluetoothMesh.devices.size} players`, 10, 580);
                }
                
                // Draw crosshair
                this.ctx.strokeStyle = '#fff';
                this.ctx.lineWidth = 1;
                this.ctx.beginPath();
                this.ctx.moveTo(this.mouse.x - 10, this.mouse.y);
                this.ctx.lineTo(this.mouse.x + 10, this.mouse.y);
                this.ctx.moveTo(this.mouse.x, this.mouse.y - 10);
                this.ctx.lineTo(this.mouse.x, this.mouse.y + 10);
                this.ctx.stroke();
                
                // Draw game info
                if (!this.player.alive) {
                    this.ctx.fillStyle = 'rgba(244, 67, 54, 0.8)';
                    this.ctx.fillRect(0, 0, 800, 600);
                    this.ctx.fillStyle = '#fff';
                    this.ctx.font = '48px Courier New';
                    this.ctx.textAlign = 'center';
                    this.ctx.fillText('YOU DIED', 400, 280);
                    this.ctx.font = '24px Courier New';
                    this.ctx.fillText('Press Respawn to continue', 400, 320);
                }
            }
            
            updateUI() {
                document.getElementById('health').textContent = this.player.health;
                document.getElementById('ammo').textContent = this.player.ammo;
                document.getElementById('kills').textContent = this.player.kills;
            }
            
            gameLoop() {
                this.update();
                this.render();
                requestAnimationFrame(() => this.gameLoop());
            }
        }
        
        // Initialize
        const bluetoothMesh = new WebBluetoothMesh();
        const game = new Game();
        
        // Global functions
        function scanForDevices() {
            bluetoothMesh.scanForDevices();
        }
        
        function hostGame() {
            bluetoothMesh.hostGame();
        }
        
        function disconnectAll() {
            bluetoothMesh.disconnectAll();
        }
        
        function respawn() {
            game.player.health = 100;
            game.player.ammo = 30;
            game.player.alive = true;
            game.player.x = 400;
            game.player.y = 300;
            
            // Broadcast respawn
            bluetoothMesh.broadcastMessage({
                type: 'respawn',
                player: 'local_player'
            });
        }
        
        function toggleFullscreen() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen();
            } else {
                document.exitFullscreen();
            }
        }
        
        function hideWarning() {
            document.getElementById('compatibilityWarning').style.display = 'none';
        }
        
        // Add some AI behavior for simulated players
        function simulateAI() {
            game.enemies.forEach((enemy, id) => {
                if (enemy.alive && id.startsWith('player_')) {
                    // Simple AI: move randomly and occasionally shoot
                    if (Math.random() < 0.02) {
                        enemy.x += (Math.random() - 0.5) * 10;
                        enemy.y += (Math.random() - 0.5) * 10;
                        enemy.x = Math.max(20, Math.min(780, enemy.x));
                        enemy.y = Math.max(20, Math.min(580, enemy.y));
                        
                        // Aim at player
                        enemy.angle = Math.atan2(game.player.y - enemy.y, game.player.x - enemy.x);
                        
                        // Occasionally shoot
                        if (Math.random() < 0.1) {
                            game.bullets.push({
                                x: enemy.x,
                                y: enemy.y,
                                angle: enemy.angle,
                                owner: id,
                                enemy: true
                            });
                        }
                    }
                }
            });
        }
        
        // Start AI simulation
        setInterval(simulateAI, 100);
        
        console.log('Web Bluetooth Mini Militia Ready!');
        console.log('Try different scan modes:');
        console.log('- Specific: Look for game players');
        console.log('- General: Scan any Bluetooth device');
        console.log('- Simulate: Create virtual network for testing');
    </script>
</body>
</html>